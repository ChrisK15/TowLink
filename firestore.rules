rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user owns this resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Check if incoming data has required fields
    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }

    // Check if field value is valid string (not empty)
    function isValidString(field) {
      return request.resource.data[field] is string
        && request.resource.data[field].size() > 0;
    }

    // Check if location object is valid
    function isValidLocation(location) {
      return location.keys().hasAll(['latitude', 'longitude'])
        && location.latitude is number
        && location.longitude is number
        && location.latitude >= -90 && location.latitude <= 90
        && location.longitude >= -180 && location.longitude <= 180;
    }

    // Check if timestamp is valid
    function isValidTimestamp(field) {
      return request.resource.data[field] is timestamp;
    }

    // Check if user has driver role
    function isDriver() {
      return isAuthenticated()
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['driver', 'both'];
    }

    // Check if user has commuter role
    function isCommuter() {
      return isAuthenticated()
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['commuter', 'both'];
    }

    // Check that a trip status transition follows the state machine order
    // cancelled is always allowed from any state
    function isValidTripTransition(currentStatus, newStatus) {
      return (currentStatus == 'en_route' && newStatus == 'arrived')
        || (currentStatus == 'arrived' && newStatus == 'in_progress')
        || (currentStatus == 'in_progress' && newStatus == 'completed')
        || newStatus == 'cancelled';
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Anyone authenticated can read any user profile
      // (needed for showing driver info to commuters and vice versa)
      allow read: if isAuthenticated();

      // Users can only create their own profile during signup
      allow create: if isAuthenticated()
        && isOwner(userId)
        && hasRequiredFields(['email', 'createdAt'])
        && isValidString('email')
        && request.resource.data.email == request.auth.token.email
        && isValidTimestamp('createdAt')
        // Role must be valid if provided
        && (request.resource.data.role == null
            || request.resource.data.role in ['commuter', 'driver', 'both']);

      // Users can only update their own profile
      allow update: if isAuthenticated()
        && isOwner(userId)
        // Cannot change critical fields
        && request.resource.data.id == resource.data.id
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt
        // Role must remain valid
        && (request.resource.data.role == null
            || request.resource.data.role in ['commuter', 'driver', 'both']);

      // Users cannot delete their own profile (use Cloud Function for account deletion)
      allow delete: if false;
    }

    // ============================================
    // REQUESTS COLLECTION
    // ============================================
    match /requests/{requestId} {
      // Any authenticated user can read requests
      // (drivers need to see all searching requests)
      allow read: if isAuthenticated();

      // Only commuters can create requests
      allow create: if isAuthenticated()
        && isCommuter()
        && hasRequiredFields([
          'commuterId',
          'location',
          'dropoffLocation',
          'pickupAddress',
          'dropoffAddress',
          'serviceType',
          'status',
          'createdAt',
          'expiresAt'
        ])
        // Must be creating request for themselves
        && request.resource.data.commuterId == request.auth.uid
        // Validate location objects
        && isValidLocation(request.resource.data.location)
        && isValidLocation(request.resource.data.dropoffLocation)
        // Address must be valid
        && isValidString('pickupAddress')
        && isValidString('dropoffAddress')
        // Service type must be 'tow'
        && request.resource.data.serviceType == 'tow'
        // Initial status must be 'searching'
        && request.resource.data.status == 'searching'
        // Timestamps must be valid
        && isValidTimestamp('createdAt')
        && isValidTimestamp('expiresAt')
        // matchedDriverId should be null initially
        && (!request.resource.data.keys().hasAny(['matchedDriverId'])
            || request.resource.data.matchedDriverId == null);

      // Commuters can cancel their own requests.
      // Drivers can claim, accept, or decline requests.
      allow update: if isAuthenticated()
        && (
          // [1] Commuter cancelling their own request (from any active status)
          (resource.data.commuterId == request.auth.uid
            && request.resource.data.status == 'cancelled'
            && request.resource.data.commuterId == resource.data.commuterId)

          ||

          // [2] Driver claiming a searching request (TOW-52)
          // Sets status: 'claimed', claimedByDriverId, claimExpiresAt, notifiedDriverIds
          (isDriver()
            && resource.data.status == 'searching'
            && request.resource.data.status == 'claimed'
            && request.resource.data.claimedByDriverId == request.auth.uid
            && request.resource.data.commuterId == resource.data.commuterId)

          ||

          // [3] Driver accepting a claimed request (finalises the claim, creates trip)
          (isDriver()
            && resource.data.status == 'claimed'
            && resource.data.claimedByDriverId == request.auth.uid
            && request.resource.data.status == 'accepted'
            && request.resource.data.matchedDriverId == request.auth.uid)

          ||

          // [4] Driver declining a claimed request (returns to searching)
          (isDriver()
            && resource.data.status == 'claimed'
            && resource.data.claimedByDriverId == request.auth.uid
            && request.resource.data.status == 'searching'
            && request.resource.data.claimedByDriverId == null)
        );

      // No one can delete requests (keep for records)
      allow delete: if false;
    }

    // ============================================
    // TRIPS COLLECTION
    // ============================================
    match /trips/{tripId} {
      // Participants can read their own trips
      allow read: if isAuthenticated()
        && (resource.data.commuterId == request.auth.uid
            || resource.data.driverId == request.auth.uid);

      // Only drivers can create trips (when accepting a request)
      allow create: if isAuthenticated()
        && isDriver()
        && hasRequiredFields([
          'requestId',
          'commuterId',
          'driverId',
          'status',
          'pickupLocation',
          'dropoffLocation',
          'startTime',
          'estimatedPrice'
        ])
        // Trip must be for the driver creating it
        && request.resource.data.driverId == request.auth.uid
        // Initial status must be 'en_route'
        && request.resource.data.status == 'en_route'
        // Validate locations
        && isValidLocation(request.resource.data.pickupLocation)
        && isValidLocation(request.resource.data.dropoffLocation)
        // Timestamps
        && isValidTimestamp('startTime')
        // Price must be positive
        && request.resource.data.estimatedPrice is number
        && request.resource.data.estimatedPrice > 0
        // Distance should be 0 initially
        && request.resource.data.distance == 0;

      // Drivers can update their trips to advance the state machine.
      // Commuters cannot update trips (read-only for them).
      allow update: if isAuthenticated()
        && resource.data.driverId == request.auth.uid
        // Cannot change core identity fields
        && request.resource.data.requestId == resource.data.requestId
        && request.resource.data.commuterId == resource.data.commuterId
        && request.resource.data.driverId == resource.data.driverId
        && request.resource.data.startTime == resource.data.startTime
        // Status must be a valid value
        && request.resource.data.status in ['en_route', 'arrived', 'in_progress', 'completed', 'cancelled']
        // Status must follow the valid state machine progression (TOW-70)
        && isValidTripTransition(resource.data.status, request.resource.data.status)
        // Timestamp validation per state transition
        && (request.resource.data.status != 'arrived'
            || isValidTimestamp('arrivalTime'))
        && (request.resource.data.status != 'in_progress'
            || isValidTimestamp('startedAt'))
        && (request.resource.data.status != 'completed'
            || isValidTimestamp('completionTime'));

      // No one can delete trips (keep for records)
      allow delete: if false;
    }

    // ============================================
    // DRIVERS COLLECTION
    // ============================================
    match /drivers/{driverId} {
      // Any authenticated user can read driver profiles
      allow read: if isAuthenticated();

      // Any authenticated user can create their own driver profile during onboarding.
      // NOTE: isDriver() check intentionally omitted — the user's role in Firestore
      // may not yet be set when the driver profile is first created (TOW-50 race condition).
      // isVerified must always start as false; it is set by admin/Cloud Function only.
      allow create: if isAuthenticated()
        && isOwner(driverId)
        && hasRequiredFields(['userId', 'isAvailable', 'isVerified', 'vehicleInfo', 'currentLocation', 'serviceRadius', 'totalTrips'])
        && request.resource.data.userId == request.auth.uid
        // Cannot self-verify on creation
        && request.resource.data.isVerified == false
        // Cannot self-mark as actively driving on creation
        && (request.resource.data.isActivelyDriving == false
            || !request.resource.data.keys().hasAny(['isActivelyDriving']));

      // Updates: driver must own the document and cannot self-verify or change userId
      allow update: if isAuthenticated()
        && isOwner(driverId)
        // isVerified is immutable from the client — only Cloud Functions/admin can change it
        && request.resource.data.isVerified == resource.data.isVerified
        // userId is immutable
        && request.resource.data.userId == resource.data.userId;

      // Cannot delete driver profiles
      allow delete: if false;
    }

    // ============================================
    // DRIVER LOCATIONS COLLECTION
    // ============================================
    // NOTE: As of Sprint 2, driverLocations is NOT written by any client-side
    // service function. updateDriverAvailability() writes to drivers/{driverId} only.
    // These rules are forward-looking for Phase 3 background location tracking.
    match /driverLocations/{driverId} {
      // Any authenticated user can read driver locations
      // (commuters need to track their driver during an active trip)
      allow read: if isAuthenticated();

      // Only the driver can create/update their own location document
      allow create, update: if isAuthenticated()
        && isOwner(driverId)
        && request.resource.data.driverId == request.auth.uid;

      // Drivers can delete their location (when going offline)
      allow delete: if isAuthenticated()
        && isOwner(driverId);
    }

    // ============================================
    // DEFAULT DENY ALL OTHER COLLECTIONS
    // ============================================
    // Any new collection is denied by default until explicitly added above.
  }
}
